(*---------------------------------------------------------------------------
  Copyright (c) 2025 Anil Madhavapeddy <anil@recoil.org>. All rights reserved.
  SPDX-License-Identifier: ISC
 ---------------------------------------------------------------------------*)

(** Bushel Markdown extensions and utilities

    This module provides mappers to convert Bushel markdown extensions to different
    output formats. Bushel extends standard markdown with:

    - [:slug] - Links to bushel entries by slug
    - [@@handle] - Links to contacts by handle
    - [##tag] - Tag references

    Two main mapper modes:
    - Sidenote mode for the main website (with previews)
    - Plain HTML mode for feeds and simple output
*)

(** {1 Sidenote Types}

    Sidenote data types for interactive previews on hover.
    These are defined here as Cmarkit inline extensions that can be
    generated by the sidenote mapper and rendered by the webserver. *)

type sidenote_data =
  | Contact_note of Sortal_schema.Contact.t * string
  | Paper_note of Bushel_paper.t * string
  | Idea_note of Bushel_idea.t * string
  | Note_note of Bushel_note.t * string
  | Project_note of Bushel_project.t * string
  | Video_note of Bushel_video.t * string
  | Footnote_note of string * Cmarkit.Block.t * string

(** Extensible inline for sidenotes *)
type Cmarkit.Inline.t += Side_note of sidenote_data

(** {1 Link Detection} *)

let is_bushel_slug = String.starts_with ~prefix:":"
let is_tag_slug link =
  String.starts_with ~prefix:"##" link &&
  not (String.starts_with ~prefix:"###" link)
let is_type_filter_slug = String.starts_with ~prefix:"###"
let is_contact_slug = String.starts_with ~prefix:"@"

let strip_handle s =
  if String.length s = 0 then s
  else if s.[0] = '@' || s.[0] = ':' then
    String.sub s 1 (String.length s - 1)
  else if String.length s > 1 && s.[0] = '#' && s.[1] = '#' then
    String.sub s 2 (String.length s - 2)
  else s

(** {1 Custom Link Resolution} *)

let authorlink = Cmarkit.Meta.key ()
let sluglink = Cmarkit.Meta.key ()

let make_authorlink label =
  let meta = Cmarkit.Meta.tag authorlink (Cmarkit.Label.meta label) in
  Cmarkit.Label.with_meta meta label

let make_sluglink label =
  let meta = Cmarkit.Meta.tag sluglink (Cmarkit.Label.meta label) in
  Cmarkit.Label.with_meta meta label

(** Custom label resolver for Bushel links *)
let with_bushel_links = function
  | `Def _ as ctx -> Cmarkit.Label.default_resolver ctx
  | `Ref (_, _, (Some _ as def)) -> def
  | `Ref (_, ref, None) ->
    let txt = Cmarkit.Label.key ref in
    if String.length txt = 0 then None
    else match txt.[0] with
      | '@' -> Some (make_authorlink ref)
      | ':' -> Some (make_sluglink ref)
      | '#' -> if String.length txt > 1 && txt.[1] = '#' then Some (make_sluglink ref) else None
      | _ -> None

(** {1 Text Extraction} *)

let text_of_inline lb =
  Cmarkit.Inline.to_plain_text ~break_on_soft:false lb
  |> fun r -> String.concat "\n" (List.map (String.concat "") r)

(** {1 Link Target Detection} *)

let link_target_is_bushel ?slugs lb =
  let open Cmarkit in
  let ref = Inline.Link.reference lb in
  match ref with
  | `Inline (ld, _) ->
    let dest = Link_definition.dest ld in
    (match dest with
     | Some (url, _) when is_bushel_slug url ->
       (match slugs with Some s -> Hashtbl.replace s url () | _ -> ());
       Some (url, Inline.Link.text lb |> text_of_inline)
     | Some (url, _) when is_tag_slug url ->
       Some (url, Inline.Link.text lb |> text_of_inline)
     | Some (url, _) when is_contact_slug url ->
       Some (url, Inline.Link.text lb |> text_of_inline)
     | _ -> None)
  | _ -> None

let image_target_is_bushel lb =
  let open Cmarkit in
  let ref = Inline.Link.reference lb in
  match ref with
  | `Inline (ld, _) ->
    let dest = Link_definition.dest ld in
    (match dest with
     | Some (url, _) when is_bushel_slug url ->
       let alt = Link_definition.title ld in
       let dir =
         Inline.Link.text lb
         |> Inline.to_plain_text ~break_on_soft:false
         |> fun r -> String.concat "\n" (List.map (String.concat "") r)
       in
       Some (url, alt, dir)
     | _ -> None)
  | _ -> None

(** {1 Sidenote Mapper}

    Creates sidenotes for Bushel links. Used for interactive previews
    on the main website. *)

let make_sidenote_mapper entries =
  let open Cmarkit in
  fun _m ->
    function
    | Inline.Link (lb, meta) ->
      (match link_target_is_bushel lb with
       | Some (url, title) ->
         let s = strip_handle url in
         if is_tag_slug url then
           (* Tag link - keep as regular link with ## prefix for renderer *)
           let txt = Inline.Text (title, meta) in
           let ld = Link_definition.make ~dest:(url, meta) () in
           let ll = `Inline (ld, meta) in
           let link = Inline.Link.make txt ll in
           Mapper.ret (Inline.Link (link, meta))
         else if is_contact_slug url then
           (* Contact sidenote *)
           (match List.find_opt (fun c -> Sortal_schema.Contact.handle c = s) (Bushel_entry.contacts entries) with
            | Some c ->
              let sidenote = Side_note (Contact_note (c, title)) in
              Mapper.ret sidenote
            | None ->
              (* Contact not found, fallback to text *)
              let txt = Inline.Text (title, meta) in
              Mapper.ret txt)
         else
           (* Check entry type and generate appropriate sidenote *)
           (match Bushel_entry.lookup entries s with
            | Some (`Paper p) ->
              let sidenote = Side_note (Paper_note (p, title)) in
              Mapper.ret sidenote
            | Some (`Idea i) ->
              let sidenote = Side_note (Idea_note (i, title)) in
              Mapper.ret sidenote
            | Some (`Note n) ->
              let sidenote = Side_note (Note_note (n, title)) in
              Mapper.ret sidenote
            | Some (`Project p) ->
              let sidenote = Side_note (Project_note (p, title)) in
              Mapper.ret sidenote
            | Some (`Video v) ->
              let sidenote = Side_note (Video_note (v, title)) in
              Mapper.ret sidenote
            | None ->
              (* Entry not found, use regular link *)
              let dest = Bushel_entry.lookup_site_url entries s in
              let txt = Inline.Text (title, meta) in
              let ld = Link_definition.make ~dest:(dest, meta) () in
              let ll = `Inline (ld, meta) in
              let link = Inline.Link.make txt ll in
              Mapper.ret (Inline.Link (link, meta)))
       | None ->
         (* Handle reference-style links *)
         (match Inline.Link.referenced_label lb with
          | Some l ->
            let m = Label.meta l in
            (match Meta.find authorlink m with
             | Some () ->
               let slug = Label.key l in
               let s = strip_handle slug in
               (match List.find_opt (fun c -> Sortal_schema.Contact.handle c = s) (Bushel_entry.contacts entries) with
                | Some c ->
                  let name = Sortal_schema.Contact.name c in
                  let sidenote = Side_note (Contact_note (c, name)) in
                  Mapper.ret sidenote
                | None ->
                  let title = Inline.Link.text lb |> text_of_inline in
                  let txt = Inline.Text (title, meta) in
                  Mapper.ret txt)
             | None ->
               (match Meta.find sluglink m with
                | Some () ->
                  let slug = Label.key l in
                  if is_bushel_slug slug then
                    let s = strip_handle slug in
                    let title = Inline.Link.text lb |> text_of_inline in
                    (match Bushel_entry.lookup entries s with
                     | Some (`Paper p) -> Mapper.ret (Side_note (Paper_note (p, title)))
                     | Some (`Idea i) -> Mapper.ret (Side_note (Idea_note (i, title)))
                     | Some (`Note n) -> Mapper.ret (Side_note (Note_note (n, title)))
                     | Some (`Project p) -> Mapper.ret (Side_note (Project_note (p, title)))
                     | Some (`Video v) -> Mapper.ret (Side_note (Video_note (v, title)))
                     | None ->
                       let dest = Bushel_entry.lookup_site_url entries s in
                       let txt = Inline.Text (title, meta) in
                       let ld = Link_definition.make ~dest:(dest, meta) () in
                       let ll = `Inline (ld, meta) in
                       let link = Inline.Link.make txt ll in
                       Mapper.ret (Inline.Link (link, meta)))
                  else if is_tag_slug slug then
                    let sh = strip_handle slug in
                    let txt = Inline.Text (sh, meta) in
                    let ld = Link_definition.make ~dest:("#", meta) () in
                    let ll = `Inline (ld, meta) in
                    let link = Inline.Link.make txt ll in
                    Mapper.ret (Inline.Link (link, meta))
                  else Mapper.default
                | None -> Mapper.default))
          | None -> Mapper.default))
    | Inline.Image (lb, meta) ->
      (* Handle images with bushel slugs *)
      (match image_target_is_bushel lb with
       | Some (url, alt, caption) ->
         let s = strip_handle url in
         (* Check if this is a video - if so, use /videos/ path *)
         (match Bushel_entry.lookup entries s with
          | Some (`Video _) ->
            let dest = Printf.sprintf "/videos/%s" s in
            let txt = Inline.Text (caption, meta) in
            let ld = Link_definition.make ?title:alt ~dest:(dest, meta) () in
            let ll = `Inline (ld, meta) in
            let img = Inline.Link.make txt ll in
            Mapper.ret (Inline.Image (img, meta))
          | _ ->
            (* Convert bushel slug to /images/ path *)
            let dest = Printf.sprintf "/images/%s.webp" s in
            let txt = Inline.Text (caption, meta) in
            let ld = Link_definition.make ?title:alt ~dest:(dest, meta) () in
            let ll = `Inline (ld, meta) in
            let img = Inline.Link.make txt ll in
            Mapper.ret (Inline.Image (img, meta)))
       | None -> Mapper.default)
    | _ -> Mapper.default

(** Alias for compatibility *)
let make_bushel_inline_mapper = make_sidenote_mapper

(** {1 Link-Only Mapper}

    Converts Bushel links to regular HTML links without sidenotes.
    Used for Atom feeds, RSS, search indexing. *)

let make_link_only_mapper entries =
  let open Cmarkit in
  fun _m ->
    function
    | Inline.Link (lb, meta) ->
      (match link_target_is_bushel lb with
       | Some (url, title) ->
         let s = strip_handle url in
         let dest = Bushel_entry.lookup_site_url entries s in
         let link_text =
           if is_bushel_slug title then
             match Bushel_entry.lookup entries (strip_handle title) with
             | Some ent -> Bushel_entry.title ent
             | None -> title
           else title
         in
         let txt = Inline.Text (link_text, meta) in
         let ld = Link_definition.make ~dest:(dest, meta) () in
         let ll = `Inline (ld, meta) in
         let ld = Inline.Link.make txt ll in
         Mapper.ret (Inline.Link (ld, meta))
       | None ->
         (match Inline.Link.referenced_label lb with
          | Some l ->
            let m = Label.meta l in
            (match Meta.find authorlink m with
             | Some () ->
               let slug = Label.key l in
               let s = strip_handle slug in
               (match List.find_opt (fun c -> Sortal_schema.Contact.handle c = s) (Bushel_entry.contacts entries) with
                | Some c ->
                  let name = Sortal_schema.Contact.name c in
                  (match Sortal_schema.Contact.best_url c with
                   | Some dest ->
                     let txt = Inline.Text (name, meta) in
                     let ld = Link_definition.make ~dest:(dest, meta) () in
                     let ll = `Inline (ld, meta) in
                     let ld = Inline.Link.make txt ll in
                     Mapper.ret (Inline.Link (ld, meta))
                   | None ->
                     let txt = Inline.Text (name, meta) in
                     Mapper.ret txt)
                | None ->
                  let title = Inline.Link.text lb |> text_of_inline in
                  let txt = Inline.Text (title, meta) in
                  Mapper.ret txt)
             | None ->
               (match Meta.find sluglink m with
                | Some () ->
                  let slug = Label.key l in
                  if is_bushel_slug slug || is_tag_slug slug || is_contact_slug slug then
                    let s = strip_handle slug in
                    let dest = Bushel_entry.lookup_site_url entries s in
                    let title = Inline.Link.text lb |> text_of_inline in
                    let link_text =
                      let trimmed = String.trim title in
                      if is_bushel_slug trimmed then
                        match Bushel_entry.lookup entries (strip_handle trimmed) with
                        | Some ent -> Bushel_entry.title ent
                        | None -> title
                      else title
                    in
                    let txt = Inline.Text (link_text, meta) in
                    let ld = Link_definition.make ~dest:(dest, meta) () in
                    let ll = `Inline (ld, meta) in
                    let ld = Inline.Link.make txt ll in
                    Mapper.ret (Inline.Link (ld, meta))
                  else Mapper.default
                | None -> Mapper.default))
          | None -> Mapper.default))
    | _ -> Mapper.default

(** Alias for compatibility *)
let make_bushel_link_only_mapper _defs = make_link_only_mapper

(** {1 Slug Scanning} *)

let scan_for_slugs entries md =
  let open Cmarkit in
  let slugs = Hashtbl.create 7 in
  let doc = Doc.of_string ~strict:false ~resolver:with_bushel_links md in
  let inline_mapper _m = function
    | Inline.Link (lb, _meta) ->
      (match link_target_is_bushel ~slugs lb with
       | Some _ -> Mapper.default
       | None ->
         (match Inline.Link.referenced_label lb with
          | Some l ->
            let m = Label.meta l in
            (match Meta.find sluglink m with
             | Some () ->
               let slug = Label.key l in
               if is_bushel_slug slug then
                 Hashtbl.replace slugs slug ();
               Mapper.default
             | None -> Mapper.default)
          | None -> Mapper.default))
    | _ -> Mapper.default
  in
  let mapper = Mapper.make ~inline:inline_mapper () in
  let _ = Mapper.map_doc mapper doc in
  ignore entries;
  Hashtbl.fold (fun k () a -> k :: a) slugs []

(** {1 Link Extraction} *)

(** Extract all links from markdown text, including from images *)
let extract_all_links text =
  let open Cmarkit in
  let doc = Doc.of_string ~resolver:with_bushel_links text in
  let links = ref [] in

  let find_links_in_inline _mapper = function
    | Inline.Link (lb, _) | Inline.Image (lb, _) ->
      (match Inline.Link.reference lb with
       | `Inline (ld, _) ->
         (match Link_definition.dest ld with
          | Some (url, _) ->
            links := url :: !links;
            Mapper.default
          | None -> Mapper.default)
       | `Ref _ ->
         (match Inline.Link.referenced_label lb with
          | Some l ->
            let key = Label.key l in
            if String.length key > 0 && (key.[0] = ':' || key.[0] = '@' ||
               (String.length key > 1 && key.[0] = '#' && key.[1] = '#')) then
              links := key :: !links;
            Mapper.default
          | None -> Mapper.default))
    | _ -> Mapper.default
  in

  let mapper = Mapper.make ~inline:find_links_in_inline () in
  let _ = Mapper.map_doc mapper doc in

  let module StringSet = Set.Make(String) in
  StringSet.elements (StringSet.of_list !links)

(** Extract external URLs from markdown content *)
let extract_external_links md =
  let open Cmarkit in
  let urls = ref [] in

  let is_external_url url =
    if is_bushel_slug url || is_tag_slug url then false
    else
      try
        let uri = Uri.of_string url in
        match Uri.scheme uri with
        | Some s when s = "http" || s = "https" -> true
        | Some _ -> true
        | None -> false
      with _ -> false
  in

  let inline_mapper _ = function
    | Inline.Link (lb, _) | Inline.Image (lb, _) ->
      let ref = Inline.Link.reference lb in
      (match ref with
       | `Inline (ld, _) ->
         (match Link_definition.dest ld with
          | Some (url, _) when is_external_url url ->
            urls := url :: !urls;
            Mapper.default
          | _ -> Mapper.default)
       | `Ref (_, _, l) ->
         let defs = Doc.defs (Doc.of_string ~strict:false md) in
         (match Label.Map.find_opt (Label.key l) defs with
          | Some (Link_definition.Def (ld, _)) ->
            (match Link_definition.dest ld with
             | Some (url, _) when is_external_url url ->
               urls := url :: !urls
             | _ -> ())
          | _ -> ());
         Mapper.default)
    | Inline.Autolink (autolink, _) ->
      let url = Inline.Autolink.link autolink |> fst in
      if not (Inline.Autolink.is_email autolink) && is_external_url url then
        urls := url :: !urls;
      Mapper.default
    | _ -> Mapper.default
  in

  let mapper = Mapper.make ~inline:inline_mapper () in
  let doc = Doc.of_string ~strict:false md in
  let _ = Mapper.map_doc mapper doc in
  List.sort_uniq String.compare !urls

(** {1 First Image Extraction} *)

let extract_first_image md =
  let open Cmarkit in
  let doc = Doc.of_string md in
  let found_image = ref None in

  let find_image_in_inline _mapper = function
    | Inline.Image (img, _) ->
      (match Inline.Link.reference img with
       | `Inline (ld, _) ->
         (match Link_definition.dest ld with
          | Some (url, _) when !found_image = None ->
            found_image := Some url;
            Mapper.default
          | _ -> Mapper.default)
       | _ -> Mapper.default)
    | _ -> Mapper.default
  in

  let mapper = Mapper.make ~inline:find_image_in_inline () in
  let _ = Mapper.map_doc mapper doc in
  !found_image

(** {1 Plaintext Conversion} *)

(** Convert markdown text to plain text, resolving bushel links to just their text *)
let markdown_to_plaintext _entries text =
  let open Cmarkit in
  let doc = Doc.of_string ~resolver:with_bushel_links text in

  let rec block_to_text = function
    | Block.Blank_line _ -> ""
    | Block.Thematic_break _ -> "\n---\n"
    | Block.Paragraph (p, _) ->
      let inline = Block.Paragraph.inline p in
      Inline.to_plain_text ~break_on_soft:false inline
      |> List.map (String.concat "") |> String.concat "\n"
    | Block.Heading (h, _) ->
      let inline = Block.Heading.inline h in
      Inline.to_plain_text ~break_on_soft:false inline
      |> List.map (String.concat "") |> String.concat "\n"
    | Block.Block_quote (bq, _) ->
      let blocks = Block.Block_quote.block bq in
      block_to_text blocks
    | Block.List (l, _) ->
      let items = Block.List'.items l in
      List.map (fun (item, _) ->
        let blocks = Block.List_item.block item in
        block_to_text blocks
      ) items |> String.concat "\n"
    | Block.Code_block (cb, _) ->
      let code = Block.Code_block.code cb in
      String.concat "\n" (List.map Block_line.to_string code)
    | Block.Html_block _ -> ""
    | Block.Link_reference_definition _ -> ""
    | Block.Ext_footnote_definition _ -> ""
    | Block.Blocks (blocks, _) ->
      List.map block_to_text blocks |> String.concat "\n"
    | _ -> ""
  in
  let blocks = Doc.block doc in
  block_to_text blocks

(** {1 Validation} *)

(** Validation mapper that collects broken references *)
let make_validation_mapper entries broken_slugs broken_contacts =
  let open Cmarkit in
  fun _m ->
    function
    | Inline.Link (lb, _meta) ->
      (match link_target_is_bushel lb with
       | Some (url, _title) ->
         let s = strip_handle url in
         if is_contact_slug url then
           (match List.find_opt (fun c -> Sortal_schema.Contact.handle c = s) (Bushel_entry.contacts entries) with
            | None -> Hashtbl.replace broken_contacts url ()
            | Some _ -> ())
         else if is_bushel_slug url then
           (match Bushel_entry.lookup entries s with
            | None -> Hashtbl.replace broken_slugs url ()
            | Some _ -> ());
         Mapper.default
       | None ->
         (match Inline.Link.referenced_label lb with
          | Some l ->
            let m = Label.meta l in
            (match Meta.find authorlink m with
             | Some () ->
               let slug = Label.key l in
               let handle = strip_handle slug in
               (match List.find_opt (fun c -> Sortal_schema.Contact.handle c = handle) (Bushel_entry.contacts entries) with
                | None -> Hashtbl.replace broken_contacts slug ()
                | Some _ -> ());
               Mapper.default
             | None ->
               (match Meta.find sluglink m with
                | None -> Mapper.default
                | Some () ->
                  let slug = Label.key l in
                  if is_bushel_slug slug then begin
                    let s = strip_handle slug in
                    match Bushel_entry.lookup entries s with
                     | None -> Hashtbl.replace broken_slugs slug ()
                     | Some _ -> ()
                  end;
                  Mapper.default))
          | None -> Mapper.default))
    | _ -> Mapper.default

(** Validate all bushel references in markdown and return broken ones *)
let validate_references entries md =
  let open Cmarkit in
  let broken_slugs = Hashtbl.create 7 in
  let broken_contacts = Hashtbl.create 7 in
  let doc = Doc.of_string ~strict:false ~resolver:with_bushel_links md in
  let mapper = Mapper.make ~inline:(make_validation_mapper entries broken_slugs broken_contacts) () in
  let _ = Mapper.map_doc mapper doc in
  let slugs = Hashtbl.fold (fun k () a -> k :: a) broken_slugs [] in
  let contacts = Hashtbl.fold (fun k () a -> k :: a) broken_contacts [] in
  (slugs, contacts)

(** {1 Markdown to Markdown Conversion} *)

(** Create a mapper that converts Bushel markdown to standard markdown.

    This resolves:
    - [:slug] links to [Title](URL)
    - [@@handle] to [Name](best_url)
    - [##tag] to [tag](/tags/tag)
    - ![:image-slug](caption) to ![caption](/images/slug.webp)
*)
let make_to_markdown_mapper ?(base_url="") ?(image_base="/images") entries =
  let open Cmarkit in
  fun _m ->
    function
    | Inline.Link (lb, meta) ->
      (match link_target_is_bushel lb with
       | Some (url, title) ->
         let s = strip_handle url in
         if is_tag_slug url then
           (* Tag link: ##tag -> [tag](/tags/tag) *)
           let dest = base_url ^ "/tags/" ^ s in
           let txt = Inline.Text (title, meta) in
           let ld = Link_definition.make ~dest:(dest, meta) () in
           let ll = `Inline (ld, meta) in
           let link = Inline.Link.make txt ll in
           Mapper.ret (Inline.Link (link, meta))
         else if is_contact_slug url then
           (* Contact link: @handle -> [Name](best_url) *)
           (match List.find_opt (fun c -> Sortal_schema.Contact.handle c = s) (Bushel_entry.contacts entries) with
            | Some c ->
              let name = Sortal_schema.Contact.name c in
              (match Sortal_schema.Contact.best_url c with
               | Some dest ->
                 let txt = Inline.Text (name, meta) in
                 let ld = Link_definition.make ~dest:(dest, meta) () in
                 let ll = `Inline (ld, meta) in
                 let link = Inline.Link.make txt ll in
                 Mapper.ret (Inline.Link (link, meta))
               | None ->
                 let txt = Inline.Text (name, meta) in
                 Mapper.ret txt)
            | None ->
              let txt = Inline.Text (title, meta) in
              Mapper.ret txt)
         else
           (* Entry link: :slug -> [Title](URL) *)
           let dest = base_url ^ Bushel_entry.lookup_site_url entries s in
           let link_text =
             if is_bushel_slug title then
               match Bushel_entry.lookup entries (strip_handle title) with
               | Some ent -> Bushel_entry.title ent
               | None -> title
             else title
           in
           let txt = Inline.Text (link_text, meta) in
           let ld = Link_definition.make ~dest:(dest, meta) () in
           let ll = `Inline (ld, meta) in
           let link = Inline.Link.make txt ll in
           Mapper.ret (Inline.Link (link, meta))
       | None ->
         (* Handle reference-style links *)
         (match Inline.Link.referenced_label lb with
          | Some l ->
            let m = Label.meta l in
            (match Meta.find authorlink m with
             | Some () ->
               let slug = Label.key l in
               let s = strip_handle slug in
               (match List.find_opt (fun c -> Sortal_schema.Contact.handle c = s) (Bushel_entry.contacts entries) with
                | Some c ->
                  let name = Sortal_schema.Contact.name c in
                  (match Sortal_schema.Contact.best_url c with
                   | Some dest ->
                     let txt = Inline.Text (name, meta) in
                     let ld = Link_definition.make ~dest:(dest, meta) () in
                     let ll = `Inline (ld, meta) in
                     let link = Inline.Link.make txt ll in
                     Mapper.ret (Inline.Link (link, meta))
                   | None ->
                     let txt = Inline.Text (name, meta) in
                     Mapper.ret txt)
                | None ->
                  let title = Inline.Link.text lb |> text_of_inline in
                  let txt = Inline.Text (title, meta) in
                  Mapper.ret txt)
             | None ->
               (match Meta.find sluglink m with
                | Some () ->
                  let slug = Label.key l in
                  if is_bushel_slug slug then
                    let s = strip_handle slug in
                    let dest = base_url ^ Bushel_entry.lookup_site_url entries s in
                    let title = Inline.Link.text lb |> text_of_inline in
                    let link_text =
                      let trimmed = String.trim title in
                      if is_bushel_slug trimmed then
                        match Bushel_entry.lookup entries (strip_handle trimmed) with
                        | Some ent -> Bushel_entry.title ent
                        | None -> title
                      else title
                    in
                    let txt = Inline.Text (link_text, meta) in
                    let ld = Link_definition.make ~dest:(dest, meta) () in
                    let ll = `Inline (ld, meta) in
                    let link = Inline.Link.make txt ll in
                    Mapper.ret (Inline.Link (link, meta))
                  else if is_tag_slug slug then
                    let s = strip_handle slug in
                    let dest = base_url ^ "/tags/" ^ s in
                    let title = Inline.Link.text lb |> text_of_inline in
                    let txt = Inline.Text (title, meta) in
                    let ld = Link_definition.make ~dest:(dest, meta) () in
                    let ll = `Inline (ld, meta) in
                    let link = Inline.Link.make txt ll in
                    Mapper.ret (Inline.Link (link, meta))
                  else Mapper.default
                | None -> Mapper.default))
          | None -> Mapper.default))
    | Inline.Image (lb, meta) ->
      (match image_target_is_bushel lb with
       | Some (url, alt, caption) ->
         (* Image: ![:slug](caption "alt") *)
         let s = strip_handle url in
         (* Convert Block_line.tight list option to string *)
         let title_text = match alt with
           | Some lines ->
             String.concat "" (List.map Cmarkit.Block_line.tight_to_string lines)
           | None -> ""
         in
         (* Check if this is a video embed *)
         (match Bushel_entry.lookup entries s with
          | Some (`Video v) ->
            (* Video embed: rewrite watch URL to embed URL *)
            let video_url = Bushel_video.url v in
            let embed_url =
              let uri = Uri.of_string video_url in
              let path = Uri.path uri |> String.split_on_char '/' in
              let path = List.map (function "watch" -> "embed" | p -> p) path in
              Uri.with_path uri (String.concat "/" path) |> Uri.to_string
            in
            let html = Printf.sprintf
              {|<div class="video-center"><iframe title="%s" width="100%%" height="315px" src="%s" frameborder="0" allowfullscreen sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe></div>|}
              title_text embed_url
            in
            let raw_html = Cmarkit.Block_line.tight_list_of_string html in
            Mapper.ret (Inline.Raw_html (raw_html, meta))
          | _ ->
            (* Image handling *)
            let img_info = Bushel_entry.lookup_image entries s in
            let dest = match img_info with
              | Some img -> image_base ^ "/" ^ Srcsetter.name img
              | None -> image_base ^ "/" ^ s ^ ".webp"
            in
            (* Check for special positioning directives *)
            (match caption with
             | "%c" | "%r" | "%lc" | "%rc" ->
               (* Generate HTML figure element *)
               let fig_class = match caption with
                 | "%c" -> "image-center"
                 | "%r" -> "image-right"
                 | "%lc" -> "image-left-float"
                 | "%rc" -> "image-right-float"
                 | _ -> "image-center"
               in
               (* Build srcset if we have image info *)
               let srcset_attr = match img_info with
                 | Some img ->
                   let variants = Srcsetter.variants img in
                   let srcset_parts = Srcsetter.MS.fold (fun name (w, _h) acc ->
                     Printf.sprintf "%s/%s %dw" image_base name w :: acc
                   ) variants [] in
                   if srcset_parts = [] then ""
                   else Printf.sprintf " srcset=\"%s\"" (String.concat ", " srcset_parts)
                 | None -> ""
               in
               let html = Printf.sprintf
                 {|<figure class="%s"><img src="%s" alt="%s" title="%s" loading="lazy"%s><figcaption>%s</figcaption></figure>|}
                 fig_class dest title_text title_text srcset_attr title_text
               in
               (* Create raw HTML as a tight block line list *)
               let raw_html = Cmarkit.Block_line.tight_list_of_string html in
               Mapper.ret (Inline.Raw_html (raw_html, meta))
             | _ ->
               (* Regular image: ![caption](url "alt") *)
               let txt = Inline.Text (caption, meta) in
               let ld = Link_definition.make ?title:alt ~dest:(dest, meta) () in
               let ll = `Inline (ld, meta) in
               let img = Inline.Link.make txt ll in
               Mapper.ret (Inline.Image (img, meta))))
       | None -> Mapper.default)
    | _ -> Mapper.default

(** Convert Bushel markdown to standard markdown.

    @param base_url Base URL prefix for entry links (default: "")
    @param image_base Base path for images (default: "/images")
    @param entries The entry collection for resolving links
    @param md The Bushel-flavored markdown text
    @return Standard markdown with all Bushel extensions resolved
*)
let to_markdown ?(base_url="") ?(image_base="/images") ~entries md =
  let open Cmarkit in
  let doc = Doc.of_string ~strict:false ~resolver:with_bushel_links md in
  let mapper = Mapper.make ~inline:(make_to_markdown_mapper ~base_url ~image_base entries) () in
  let mapped_doc = Mapper.map_doc mapper doc in
  Cmarkit_commonmark.of_doc mapped_doc

(** {1 References}

    Reference extraction for CiTO annotations. *)

(** Reference source type for CiTO annotations *)
type reference_source =
  | Paper  (** CitesAsSourceDocument *)
  | Note   (** CitesAsRelated *)
  | External  (** Cites *)

(** Extract references (papers/notes with DOIs) from a note.
    Returns a list of (doi, citation_text, reference_source) tuples.

    @param entries The entry collection
    @param default_author The default author contact for notes without explicit author
    @param note The note to extract references from *)
let note_references entries (default_author:Sortal_schema.Contact.t) note =
  let refs = ref [] in

  (* Helper to format author name: extract last name from full name *)
  let format_author_last name =
    let parts = String.split_on_char ' ' name in
    List.nth parts (List.length parts - 1)
  in

  (* Helper to format a citation *)
  let format_citation ~authors ~year ~title ~publisher =
    let author_str = match authors with
      | [] -> ""
      | [author] -> format_author_last author ^ " "
      | author :: _ -> (format_author_last author) ^ " et al "
    in
    let pub_str = match publisher with
      | None | Some "" -> ""
      | Some p -> p ^ ". "
    in
    Printf.sprintf "%s(%d). %s. %s" author_str year title pub_str
  in

  (* Check slug_ent if it exists *)
  (match Bushel_note.slug_ent note with
   | Some slug ->
     (match Bushel_entry.lookup entries slug with
      | Some (`Paper p) ->
        (match Bushel_paper.doi p with
         | Some doi ->
           let authors = Bushel_paper.authors p in
           let year = Bushel_paper.year p in
           let title = Bushel_paper.title p in
           let publisher = Some (Bushel_paper.publisher p) in
           let citation = format_citation ~authors ~year ~title ~publisher in
           refs := (doi, citation, Paper) :: !refs
         | None -> ())
      | Some (`Note n) ->
        (match Bushel_note.doi n with
         | Some doi ->
           let authors = match Bushel_note.author n with
             | Some a -> [a]
             | None -> [Sortal_schema.Contact.name default_author]
           in
           let (year, _, _) = Bushel_note.date n in
           let title = Bushel_note.title n in
           let publisher = None in
           let citation = format_citation ~authors ~year ~title ~publisher in
           refs := (doi, citation, Note) :: !refs
         | None -> ())
      | _ -> ())
   | None -> ());

  (* Scan body for bushel references *)
  let slugs = scan_for_slugs entries (Bushel_note.body note) in
  List.iter (fun slug ->
    (* Strip leading : or @ from slug before lookup *)
    let normalized_slug = strip_handle slug in
    match Bushel_entry.lookup entries normalized_slug with
    | Some (`Paper p) ->
      (match Bushel_paper.doi p with
       | Some doi ->
         let authors = Bushel_paper.authors p in
         let year = Bushel_paper.year p in
         let title = Bushel_paper.title p in
         let publisher = Some (Bushel_paper.publisher p) in
         let citation = format_citation ~authors ~year ~title ~publisher in
         (* Check if doi already exists in refs *)
         if not (List.exists (fun (d, _, _) -> d = doi) !refs) then
           refs := (doi, citation, Paper) :: !refs
       | None -> ())
    | Some (`Note n) ->
      (match Bushel_note.doi n with
       | Some doi ->
         let authors = match Bushel_note.author n with
           | Some a -> [a]
           | None -> [Sortal_schema.Contact.name default_author]
         in
         let (year, _, _) = Bushel_note.date n in
         let title = Bushel_note.title n in
         let publisher = None in
         let citation = format_citation ~authors ~year ~title ~publisher in
         (* Check if doi already exists in refs *)
         if not (List.exists (fun (d, _, _) -> d = doi) !refs) then
           refs := (doi, citation, Note) :: !refs
       | None -> ())
    | _ -> ()
  ) slugs;

  (* Scan body for external DOI URLs and resolve from cache *)
  let body = Bushel_note.body note in
  let doi_url_pattern = Re.Perl.compile_pat "https?://(?:dx\\.)?doi\\.org/([^)\\s\"'>]+)" in
  let doi_matches = Re.all doi_url_pattern body in
  let doi_entries = Bushel_entry.doi_entries entries in
  List.iter (fun group ->
    try
      let encoded_doi = Re.Group.get group 1 in
      let doi = Uri.pct_decode encoded_doi in
      if not (List.exists (fun (d, _, _) -> d = doi) !refs) then
        match Bushel_doi_entry.find_by_doi doi_entries doi with
        | Some doi_entry when doi_entry.status = Resolved ->
          let citation = format_citation
            ~authors:doi_entry.authors
            ~year:doi_entry.year
            ~title:doi_entry.title
            ~publisher:(Some doi_entry.publisher)
          in
          refs := (doi, citation, External) :: !refs
        | _ ->
          refs := (doi, doi, External) :: !refs
    with _ -> ()
  ) doi_matches;

  (* Scan body for publisher URLs and resolve from DOI cache *)
  let publisher_pattern = Re.Perl.compile_pat "https?://(?:(?:www\\.)?(?:linkinghub\\.elsevier\\.com|(?:www\\.)?sciencedirect\\.com/science/article|ieeexplore\\.ieee\\.org|academic\\.oup\\.com|nature\\.com|journals\\.sagepub\\.com|garfield\\.library\\.upenn\\.edu|link\\.springer\\.com|arxiv\\.org/abs)/[^)\\s\"'>]+|(?:dl\\.acm\\.org|(?:www\\.)?tandfonline\\.com)/doi(?:/pdf)?/10\\.[^)\\s\"'>]+)" in
  let publisher_matches = Re.all publisher_pattern body in
  List.iter (fun group ->
    try
      let url = Re.Group.get group 0 in
      match Bushel_doi_entry.find_by_url doi_entries url with
      | Some doi_entry when doi_entry.status = Resolved ->
        let doi = doi_entry.doi in
        if not (List.exists (fun (d, _, _) -> d = doi) !refs) then
          let citation = format_citation
            ~authors:doi_entry.authors
            ~year:doi_entry.year
            ~title:doi_entry.title
            ~publisher:(Some doi_entry.publisher)
          in
          refs := (doi, citation, External) :: !refs
      | _ -> ()
    with _ -> ()
  ) publisher_matches;

  (* Filter out the note's own DOI from references *)
  let own_doi = Bushel_note.doi note in
  let filtered_refs = List.filter (fun (doi, _, _) ->
    match own_doi with
    | Some own -> doi <> own
    | None -> true
  ) !refs in
  List.rev filtered_refs
